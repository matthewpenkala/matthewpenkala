/*
 * fitty v2.2.6 - Snugly resizes text to fit its parent container
 * Source: https://github.com/rikschennink/fitty
 * Converted to ES module by removing the UMD wrapper and exporting a default.
 */

'use strict';

/**
 * Polyfill for Object.assign if needed
 */
const _assign = Object.assign || function (target) {
  for (let i = 1; i < arguments.length; i++) {
    const source = arguments[i];
    for (const key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};

/**
 * Creates the core Fitty module, assuming a `window`-like object (with requestAnimationFrame, etc).
 */
function createFitty(windowObj) {
  // If we don't have a valid window-like object, return a no-op function
  if (!windowObj) {
    // Return a dummy function in case Fitty is called in a non-browser env
    return function() {
      console.warn('Fitty: window is not available.');
    };
  }

  const i = elements => [].slice.call(elements);
  const states = {
    IDLE: 0,
    DIRTY_CONTENT: 1,
    DIRTY_LAYOUT: 2,
    DIRTY: 3
  };

  let fittyInstances = [];
  let rafId = null;

  const requestUpdate = 'requestAnimationFrame' in windowObj
    ? () => {
      windowObj.cancelAnimationFrame(rafId);
      rafId = windowObj.requestAnimationFrame(() => {
        process(fittyInstances.filter(f => f.dirty));
      });
    }
    : () => {}; // Fallback no-op if RAF not available

  function setAllDirty(dirtyType) {
    return () => {
      fittyInstances.forEach(inst => { inst.dirty = dirtyType; });
      requestUpdate();
    };
  }

  function process(instances) {
    // Compute style where needed
    instances.filter(inst => !inst.styleComputed)
      .forEach(inst => { inst.styleComputed = computeStyle(inst); });

    // Apply pre-styles
    instances.filter(needsPreStyle)
      .forEach(applyStyle);

    // Recalculate
    const active = instances.filter(needsCalc);
    active.forEach(calcFontSize);
    active.forEach(inst => {
      applyStyle(inst);
      markClean(inst);
    });
    active.forEach(fireFitEvent);
  }

  function markClean(inst) {
    inst.dirty = states.IDLE;
  }

  function calcFontSize(inst) {
    inst.availableWidth = inst.element.parentNode.clientWidth;
    inst.currentWidth = inst.element.scrollWidth;
    inst.previousFontSize = inst.currentFontSize;
    inst.currentFontSize = Math.min(
      Math.max(
        inst.minSize,
        (inst.availableWidth / inst.currentWidth) * inst.previousFontSize
      ),
      inst.maxSize
    );
    inst.whiteSpace =
      inst.multiLine && inst.currentFontSize === inst.minSize
        ? 'normal'
        : 'nowrap';
  }

  function needsCalc(inst) {
    // Dirty if IDLE->DIRTY_LAYOUT or parent width changed
    if (inst.dirty !== states.DIRTY_LAYOUT) return inst.dirty === states.DIRTY;
    return (
      inst.element.parentNode.clientWidth !== inst.availableWidth
    );
  }

  function computeStyle(inst) {
    const style = windowObj.getComputedStyle(inst.element, null);
    inst.currentFontSize = parseInt(style.getPropertyValue('font-size'), 10);
    inst.display = style.getPropertyValue('display');
    inst.whiteSpace = style.getPropertyValue('white-space');
  }

  function needsPreStyle(inst) {
    // Convert inline elements to inline-block, force no-wrap
    if (!inst.preStyleTestCompleted) {
      let changed = false;
      if (/inline-/.test(inst.display)) {
        changed = true;
        inst.display = 'inline-block';
      }
      if (inst.whiteSpace !== 'nowrap') {
        changed = true;
        inst.whiteSpace = 'nowrap';
      }
      inst.preStyleTestCompleted = true;
      return changed;
    }
    return false;
  }

  function applyStyle(inst) {
    if (!inst.originalStyle) {
      inst.originalStyle = inst.element.getAttribute('style') || '';
    }
    inst.element.style.cssText =
      inst.originalStyle +
      ';white-space:' + inst.whiteSpace +
      ';display:' + inst.display +
      ';font-size:' + inst.currentFontSize + 'px';
  }

  function fireFitEvent(inst) {
    inst.element.dispatchEvent(
      new CustomEvent('fit', {
        detail: {
          oldValue: inst.previousFontSize,
          newValue: inst.currentFontSize,
          scaleFactor: inst.currentFontSize / inst.previousFontSize
        }
      })
    );
  }

  function makeDirty(inst, dirtyType) {
    return () => {
      inst.dirty = dirtyType;
      requestUpdate();
    };
  }

  function subscribe(inst) {
    inst.newbie = true;
    inst.dirty = true;
    fittyInstances.push(inst);
  }

  function unsubscribe(inst) {
    return () => {
      fittyInstances = fittyInstances.filter(f => f.element !== inst.element);
      if (inst.observeMutations) {
        inst.observer.disconnect();
      }
      inst.element.style.cssText = inst.originalStyle;
    };
  }

  function observe(inst) {
    if (inst.observeMutations) {
      inst.observer = new MutationObserver(makeDirty(inst, states.DIRTY_CONTENT));
      inst.observer.observe(inst.element, inst.observeMutations);
    }
  }

  const defaultOptions = {
    minSize: 16,
    maxSize: 512,
    multiLine: true,
    observeMutations:
      'MutationObserver' in windowObj && {
        subtree: true,
        childList: true,
        characterData: true
      }
  };

  let resizeDebounce = null;
  const onWindowResize = () => {
    windowObj.clearTimeout(resizeDebounce);
    resizeDebounce = windowObj.setTimeout(setAllDirty(states.DIRTY_LAYOUT), fitty.observeWindowDelay);
  };

  const events = ['resize', 'orientationchange'];

  /**
   * Our final `fitty` object that gets returned.
   */
  function fitty(target, options = {}) {
    // Query by string or take array/element
    if (typeof target === 'string') {
      const elements = i(document.querySelectorAll(target));
      return createFitInstances(elements, options);
    } else {
      const instances = createFitInstances([target], options);
      return instances[0]; // If single element, return first for chaining
    }
  }

  /**
   * Fit all existing Fitty elements (set them all dirty -> recalc).
   */
  fitty.fitAll = setAllDirty(states.DIRTY);

  /**
   * Whether we automatically observe window resizing
   */
  Object.defineProperty(fitty, 'observeWindow', {
    set(enabled) {
      const method = (enabled ? 'add' : 'remove') + 'EventListener';
      events.forEach(ev => {
        windowObj[method](ev, onWindowResize);
      });
    }
  });

  fitty.observeWindow = true;
  fitty.observeWindowDelay = 100;

  /**
   * Internal function to create instances.
   */
  function createFitInstances(elementArray, customOptions) {
    const mergedOptions = _assign({}, defaultOptions, customOptions);

    const newInstances = elementArray.map(element => {
      const inst = _assign({}, mergedOptions, { element });
      subscribe(inst);
      observe(inst);
      return {
        element,
        fit: makeDirty(inst, states.DIRTY),
        unsubscribe: unsubscribe(inst)
      };
    });

    // Trigger an async measure
    requestUpdate();
    return newInstances;
  }

  return fitty;
}

/**
 * Create a Fitty instance for the current environment (if `window` is available).
 */
const fitty = createFitty(
  typeof window !== 'undefined' ? window : null
);

export default fitty;
