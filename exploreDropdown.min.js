$(function() {
    // -------------------------------------
    // Configuration & State
    // -------------------------------------
    const DROPDOWN_LIST_SELECTOR = '#w-dropdown-list-0';
    const OPEN_CLASS             = 'w--open';
    const ROTATION_DURATION      = 250;    // ms
    const RECHECK_DELAY          = 500;    // ms
    let isArrowOpen              = false;

    // -------------------------------------
    // Element References
    // -------------------------------------
    const hoverableElements = $("[class*='navbar-menu-item']")
        .filter((_, el) => $(el).text().includes('Explore'))
        .closest("[data-hover]")
        .find("*:not(path)");

    const $toggleElement = hoverableElements.filter(".w-dropdown-toggle").first();
    const $arrowElement  = hoverableElements.find("svg").parent().first();
    const $dropdownList  = $(DROPDOWN_LIST_SELECTOR);

    // Initialize arrow state
    $arrowElement.css("transform", "rotate(0deg)");

    // -------------------------------------
    // Easing & Animation Functions
    // -------------------------------------
    const customEasing = t => (t < 0.5)
        ? 4 * t * t * t
        : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;

    const rotateArrow = (element, duration, open) => new Promise(resolve => {
        const [startAngle, endAngle] = open ? [0, 180] : [180, 0];
        const startTime = performance.now();

        const animate = timestamp => {
            const elapsed  = timestamp - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased    = customEasing(progress);
            element.style.transform = `rotate(${startAngle + (endAngle - startAngle) * eased}deg)`;
            (elapsed < duration) ? requestAnimationFrame(animate) : resolve();
        };

        requestAnimationFrame(animate);
    });

    // -------------------------------------
    // Helper: Open Arrow if not already
    // -------------------------------------
    const openArrowIfClosed = () => {
        if (!isArrowOpen && $arrowElement.length) {
            $toggleElement.addClass("w-hover");
            rotateArrow($arrowElement[0], ROTATION_DURATION, true).then(() => {
                isArrowOpen = true;
            });
        }
    };

    // -------------------------------------
    // Event Handlers
    // -------------------------------------
    $toggleElement.hover(openArrowIfClosed);
    $toggleElement.click(openArrowIfClosed);

    // -------------------------------------
    // MutationObserver: Watches for dropdown close
    // -------------------------------------
    const observer = new MutationObserver(mutations => {
        for (const mutation of mutations) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                const currentlyOpen = $dropdownList.hasClass(OPEN_CLASS);
                if (!currentlyOpen && isArrowOpen) {
                    // Immediately close arrow
                    $toggleElement.removeClass("w-hover");
                    rotateArrow($arrowElement[0], ROTATION_DURATION, false).then(() => {
                        isArrowOpen = false;
                    });

                    // After delay, re-check and ensure arrow is closed if still not open
                    setTimeout(() => {
                        if (!$dropdownList.hasClass(OPEN_CLASS) && !isArrowOpen) {
                            $toggleElement.removeClass("w-hover");
                            rotateArrow($arrowElement[0], ROTATION_DURATION, false).then(() => {
                                isArrowOpen = false;
                            });
                        }
                    }, RECHECK_DELAY);
                }
            }
        }
    });

    observer.observe($dropdownList[0], { attributes: true });
});
